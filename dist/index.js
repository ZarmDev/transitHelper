var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import GtfsRealTimeBindings from 'gtfs-realtime-bindings';
import express from 'express';
// import cors from 'cors';
import fs from 'fs/promises';
const app = express();
const PORT = 8082;
function writeToFile(filename, content) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield fs.writeFile(filename, content);
        }
        catch (err) {
            console.error('Error:', err);
        }
    });
}
function parseAndReturnFeed(url) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield fetch(url, {
            method: 'GET',
            headers: {
            // ...
            },
        });
        if (!response.ok) {
            const error = new Error(`${response.url}: ${response.status} ${response.statusText}`);
            throw error;
        }
        const buffer = yield response.arrayBuffer();
        // Convert ArrayBuffer to Uint8Array
        const uint8Array = new Uint8Array(buffer);
        const feed = GtfsRealTimeBindings.transit_realtime.FeedMessage.decode(uint8Array);
        return feed;
    });
}
const trainAlerts = {};
function getServiceAlerts() {
    return __awaiter(this, void 0, void 0, function* () {
        const feed = yield parseAndReturnFeed("https://api-endpoint.mta.info/Dataservice/mtagtfsfeeds/camsys%2Fsubway-alerts");
        // Where all the data is. The other key is header, used for metadata
        const processed = feed["entity"];
        // writeToFile(JSON.stringify(processed, null, 2))
        for (var i = 0; i < processed.length; i++) {
            // console.log(processed[i])
            const id = processed[i]["id"];
            // make sure the id is a current alert and not planned alert
            // console.log(id, !id.includes('lmm:alert'))
            if (!id.includes('lmm:alert')) {
                // console.log(id);
                break;
            }
            else {
                // console.log(id, true);
            }
            if (processed[i]["alert"] != undefined) {
                const alert = processed[i]["alert"];
                const routesAffected = alert["informedEntity"];
                const header = alert["headerText"];
                console.log(header);
                const description = alert["descriptionText"];
                const headerTextTranslation = header["translation"];
                const descriptionTranslation = description == null ? null : description["translation"];
                // you can either use index 0 or 1 which either gives you the normal version or version in HTML
                const headerText = headerTextTranslation[1]["text"];
                const descriptionText = description == null ? null : descriptionTranslation[1]["text"];
                // console.log(routesAffected.length)
                const routeId = routesAffected[0]['routeId'];
                trainAlerts[routeId] = `${headerText} \n${descriptionText}`;
                // for (var i = 0; i < routesAffected.length; i++) {
                //     const routeId = routesAffected[i]['routeId']
                //     trainAlerts[routeId] = `${headerText} \n${descriptionText}`
                // }
            }
            if (i > 100) {
                console.log('damn');
                break;
            }
        }
        return trainAlerts;
    });
}
// generated by AI cuz im lazy
function unixTimestampToDateTime(unixTimestamp) {
    const milliseconds = unixTimestamp * 1000; // Convert seconds to milliseconds
    const date = new Date(milliseconds);
    return date;
}
function getArrivals(line, targetStopID) {
    return __awaiter(this, void 0, void 0, function* () {
        let source = "";
        if (["A", "C", "E"].includes(line)) {
            source = "https://api-endpoint.mta.info/Dataservice/mtagtfsfeeds/nyct%2Fgtfs-ace";
        }
        else if (["B", "D", "F", "M"].includes(line)) {
            source = "https://api-endpoint.mta.info/Dataservice/mtagtfsfeeds/nyct%2Fgtfs-bdfm";
        }
        else if (["G"].includes(line)) {
            source = "https://api-endpoint.mta.info/Dataservice/mtagtfsfeeds/nyct%2Fgtfs-g";
        }
        else if (["J", "Z"].includes(line)) {
            source = "https://api-endpoint.mta.info/Dataservice/mtagtfsfeeds/nyct%2Fgtfs-jz";
        }
        else if (["N", "Q", "R", "W"].includes(line)) {
            source = "https://api-endpoint.mta.info/Dataservice/mtagtfsfeeds/nyct%2Fgtfs-nqrw";
        }
        else if (["L"].includes(line)) {
            source = "https://api-endpoint.mta.info/Dataservice/mtagtfsfeeds/nyct%2Fgtfs-l";
        }
        else if (["1", "2", "3", "4", "5", "6", "7"].includes(line)) {
            source = "https://api-endpoint.mta.info/Dataservice/mtagtfsfeeds/nyct%2Fgtfs";
        }
        else if (["SIR"].includes(line)) {
            source = "https://api-endpoint.mta.info/Dataservice/mtagtfsfeeds/nyct%2Fgtfs-si";
        }
        const feed = yield parseAndReturnFeed(source);
        // console.log(feed);
        // what are entities? idk :/
        const entities = feed["entity"];
        var obj = {};
        for (var i = 0; i < entities.length; i++) {
            // trip data for each train? not sure
            const tripUpdate = entities[i]["tripUpdate"];
            if (tripUpdate == null || tripUpdate == undefined) {
                continue;
            }
            const trip = tripUpdate["trip"];
            const tripID = trip["tripId"];
            const routeID = trip["routeId"];
            // not sure if this works for all lines... maybe not working for SIR
            if (routeID != line) {
                continue;
            }
            // all the arrivals for each stop in stops.txt (google_transit folder)
            const stopTimeUpdate = tripUpdate["stopTimeUpdate"];
            for (let j = 0; j < stopTimeUpdate.length; j++) {
                let stopID = stopTimeUpdate[j]["stopId"];
                // the stopID looks like "R20N" and it can either be
                // R20, R20S, R20N representing the direction the arrival times are bound
                if (stopID === targetStopID) {
                    let time = stopTimeUpdate[j]["arrival"]["time"];
                    let timeDifference = unixTimestampToDateTime(time) - Date.now();
                    timeDifference = Math.round(timeDifference / (1000 * 60));
                    const data = yield fs.readFile("./google_transit/stops.txt", 'utf-8');
                    const splitByLine = data.split('\n');
                    for (var x = 0; x < splitByLine.length; x++) {
                        if (splitByLine[x] == '') {
                            continue;
                        }
                        const splitByComma = splitByLine[x].split(',');
                        // console.log(splitByComma[0], targetStopID)
                        if (splitByComma[0].includes(targetStopID)) {
                            let realStopName = splitByComma[1];
                            obj[i] = `${line} arrives in ${timeDifference} minutes at ${realStopName}`;
                        }
                    }
                }
            }
        }
        return obj;
    });
}
function getTrainLineCoordinates(data) {
    return __awaiter(this, void 0, void 0, function* () {
        var splitByLine = data.split('\n');
        var trainLines = [
            { coordinates: [{ latitude: 37.78825, longitude: -122.4324 }, { latitude: 37.75825, longitude: -122.4424 }], color: '#FF0000' },
        ];
        var trainStops = [
            { latitude: 40.709166, longitude: -74.004901, title: 'Example' }
        ];
        for (var i = 0; i < splitByLine.length; i += 1) {
            var splitByComma = splitByLine[i].split(',');
            var splitByComma2 = splitByLine[i + 1].split(',');
            trainLines.push({
                coordinates: [
                    { latitude: parseFloat(splitByComma[2]), longitude: parseFloat(splitByComma[3]) },
                    { latitude: parseFloat(splitByComma2[2]), longitude: parseFloat(splitByComma2[3]) }
                ],
                color: '#FF0000'
            });
        }
    });
}
function getTrainStopCoordinates(data) {
    return __awaiter(this, void 0, void 0, function* () {
    });
}
// getAllData returns an object like:
/*
{
    "stopID": {
        "coordinates": {longitude: "", latitude: ""},
        "trains": {"N, Q, R, W"},
        "name": "34st Herald Square"
    },
    >> example
    "R27": {
        "coordinates": {longitude: "40.703087", latitude: "-74.012994"},
        "trains": {"N": "#FFFD37", Q: "#FFFD37", R: "#FFFD37", W: "#FFFD37"},
        "name": "Whitehall St-South Ferry",
        "icon": "1.svg, r.svg, w.svg"
    }
}
*/
function getAllData() {
    return __awaiter(this, void 0, void 0, function* () {
    });
}
app.get('/serviceAlerts', (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const alerts = yield getServiceAlerts();
        res.json(alerts); // Send the alerts as JSON
    }
    catch (error) {
        res.status(500).send(error.message);
    }
}));
app.get('/realtimeTrainData', (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        // to test
        const currentCoords = '40.889248,-73.898583';
        const line = 'Q';
        const direction = "N";
        const realtime = yield getArrivals(line, currentStop, direction);
        res.json(realtime); // Send the alerts as JSON
    }
    catch (error) {
        res.status(500).send(error.message);
    }
}));
app.listen(PORT, () => {
    console.log(`Server is running on http://localhost:${PORT}`);
});
//# sourceMappingURL=index.js.map